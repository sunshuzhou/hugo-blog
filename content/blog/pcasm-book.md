+++
date = "2017-05-01T13:13:14+08:00"
description = ""
title = "PC Assembly Language"

+++

一本来自[Paul Carter](http://pacman128.github.io/pcasm/)的免费电子书，讲述了32位保护模式下的汇编语言。


# Chapter 1. Introduction

## 基础
- 介绍了数字的不同表示形式，不同进制（2、8、10和16）之间是可以互相转换的。因为二进制形式能简化硬件实现，所以计算机底层以二进制存储所有信息。
- 内存的基本单位是字节（byte），每个内存都有相应的地址，以便访问。
- 虽然在编程时有各种数据类型，如整型、字符串类型等。但是实际上，内存中的数据都是数字。字符类型使用映射将每个字符映射成相应的数字，存储进内存，更进一步写入硬盘中。映射又成为编码方式。ASCII就是其中最常用的一种，占用一个字节，所以最多能表示256个字符。实际上，ASCII只使用了7位，所以只表示128个字符。更现代的一种编码方式是Unicode，它占用两个字节，支持世界上所有语言的编码。
- CPU负责顺序执行机器指令。通常利用寄存器能更快的执行，然而寄存器的数量是有限的，因此CPU只会将当前使用的数据加载进寄存器。
- 高级语言编写的程序需要经过编译器（`compiler`）转换成机器语言，才能被CPU认识和执行。通常，不同类型的CPU拥有自己的机器语言，因此为不同平台开发的程序存在兼容性问题。
- 计算机使用时钟来同步指令的执行。时钟按照固定的时间频率触发。

## 80x86系列

- 8088，8086：16位实模式
- 80286：16位保护模式
- 80386：32位保护模式

### 80386

- 寄存器扩展为32位：`EAX`、`EBX`、`ECX`、`EDX`、`ESI`、`EDI`、`ESP`、`EFLAGS`和`EIP`
- 段寄存器还是16位，增加了两个：`ES`、`FS`和`GS`

### 32位保护模式

- 32位偏移，段的大小为4G
- 段页式虚拟内存机制，段被分为4K大小的页

## 汇编语言

- 编译器（`compiler`）负责把高级语言转换成机器语言；汇编器（`assembler`）负责把汇编语言转换成机器语言。编译器比汇编器要复杂很多，因为一条汇编语句可以直接转换成相应的机器指令，而一条高级语句可能需要完成十分多的工作。移植汇编语句和移植机器指令一样困难。
- 本书使用NASM作为汇编器。
- 基本语法规则：操作命令 操作符，如`add eax, ebx`

### 操作符类型

- 寄存器
- 内存
- 直接值
- 隐含值

### 操作命令
#### MOV
`mov dest, src`：将数据从src拷贝到dest，src和dest必须要有相同的长度，都是32位或16位，且不能为内存类型。

例:

- `mov eax, 3 ; store 3 into EAX register (3 is immediate operand)`- `mov bx, ax ; store the value of AX into the BX register`

#### ADD
- `add eax, 4 ; eax = eax + 4`- `add al, ah ; al = al + ah`

#### SUB
- `sub bx, 10 ; bx = bx - 10`- `sub ebx, edi ; ebx = ebx - edi`

#### INC和DEC

- `inc ecx ; ecx++`- `dec dl ; dl--`


### 汇编指令

部分汇编指令只是为了传递给汇编器，不会编译成机器语言。

- 定义符号：`symbol equ value`
- 定义宏：`%define SIZE 100`

宏比符号更灵活，宏可以重定义，而且可以定义成字符串

